Discussion

TRAILS
Set: [3, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 2, 5, 3, 1, 1, 2, 3, 3, 2, 2, 2, 2, 4, 3, 4, 5, 4, 4, 5]
Map: [0, 0, 1, 1, 0, 6, 3, 1, 1, 1, 2, 2, 2, 4, 2, 2, 2, 4, 2, 2, 2, 3, 5, 4, 4, 4, 5, 5, 6, 6]
USERS
Set: [1, 0, 0, 0, 0, 1, 0, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 3, 2, 2, 4, 4, 5, 6, 3, 4, 5, 5, 7, 6]
Map: [0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 1, 1, 2, 2, 2, 3, 3, 2, 3, 4, 3, 5, 4, 7, 4, 6, 5, 7, 6]
HISTORY
LINKEDLIST: [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4]

	During this project, my task was to find the best choice for data structures for specific scenarios.
	These specific scenarios were three: users, trails, and history. For Users, we need something fast since Users are
	verified before the app does anything useful. User's also need to be expandable so that we can keep our base growing.
	Trees provide the best agility, so i tried tree maps and tree sets. The deciding factor between the two was that maps 
	need a unique key. This works great as i can use the username for a key and the object as the value, since usernames
	should also be unique.
	For Trails, most of the same conditions apply. Although, we can have trails with the same name in them. This pushed me
	towards the Set since duplicates are allowed. Lastly, History was chosen through logic since, we needed a data structure
	that held onto the order of objects. Stacks were immediately disregarded since its is A LIFO data structure.
	LinkedList worked very well and is expandable. As well as very useful in order to retrieve multiple trails 
	with the same word in them.
	Above are sample results from my test trials.
	Run demo to see for yourself :)
	
	